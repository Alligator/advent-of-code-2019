use std::collections::HashSet;

#[derive(PartialEq, Debug)]
struct Asteroid {
    x: f32,
    y: f32,
}

fn slope(a: &Asteroid, b: &Asteroid) -> f32 {
    (b.y - a.y) / (b.x - a.x)
}

fn main() {
    let input = "\
##.###.#.......#.#....#....#..........#.
....#..#..#.....#.##.............#......
...#.#..###..#..#.....#........#......#.
#......#.....#.##.#.##.##...#...#......#
.............#....#.....#.#......#.#....
..##.....#..#..#.#.#....##.......#.....#
.#........#...#...#.#.....#.....#.#..#.#
...#...........#....#..#.#..#...##.#.#..
#.##.#.#...#..#...........#..........#..
........#.#..#..##.#.##......##.........
................#.##.#....##.......#....
#............#.........###...#...#.....#
#....#..#....##.#....#...#.....#......#.
.........#...#.#....#.#.....#...#...#...
.............###.....#.#...##...........
...#...#.......#....#.#...#....#...#....
.....#..#...#.#.........##....#...#.....
....##.........#......#...#...#....#..#.
#...#..#..#.#...##.#..#.............#.##
.....#...##..#....#.#.##..##.....#....#.
..#....#..#........#.#.......#.##..###..
...#....#..#.#.#........##..#..#..##....
.......#.##.....#.#.....#...#...........
........#.......#.#...........#..###..##
...#.....#..#.#.......##.###.###...#....
...............#..#....#.#....#....#.#..
#......#...#.....#.#........##.##.#.....
###.......#............#....#..#.#......
..###.#.#....##..#.......#.............#
##.#.#...#.#..........##.#..#...##......
..#......#..........#.#..#....##........
......##.##.#....#....#..........#...#..
#.#..#..#.#...........#..#.......#..#.#.
#.....#.#.........#............#.#..##.#
.....##....#.##....#.....#..##....#..#..
.#.......#......#.......#....#....#..#..
...#........#.#.##..#.#..#..#........#..
#........#.#......#..###....##..#......#
...#....#...#.....#.....#.##.#..#...#...
#.#.....##....#...........#.....#...#...\
";

    let mut asteroids = Vec::new();
    for (y, line) in input.split_whitespace().enumerate() {
        for (x, c) in line.chars().enumerate() {
            if c == '#' {
                asteroids.push(Asteroid { x: x as f32, y: y as f32 });
            }
        }
    }

    let mut ranked_asteroids = Vec::new();
    for asteroid in asteroids.iter() {
        let mut slopes = HashSet::new();

        for other_asteroid in asteroids.iter() {
            if other_asteroid == asteroid {
                continue;
            }

            let s = slope(asteroid, other_asteroid);
            let s_str = format!("{:.4}", s);

            let dx_sign = if asteroid.x - other_asteroid.x < 0.0 { -1 } else { 1 };
            let dy_sign = if asteroid.y - other_asteroid.y < 0.0 { -1 } else { 1 };

            slopes.insert((s_str, dx_sign, dy_sign));
        }
        ranked_asteroids.push((asteroid, slopes.len()));
    }

    ranked_asteroids.sort_by_key(|x| x.1);
    ranked_asteroids.reverse();

    for asteroid in &ranked_asteroids[..5] {
        println!("{:?}", asteroid);
    }
}
